/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

import { objectWithoutProperties as _objectWithoutProperties, slicedToArray as _slicedToArray, defineProperty as _defineProperty, extends as _extends, objectSpread2 as _objectSpread2 } from '../../_virtual/_rollupPluginBabelHelpers.js';
import cx from 'classnames';
import Downshift from 'downshift';
import PropTypes from 'prop-types';
import React__default, { useContext, useRef, useState, useEffect } from 'react';
import '../Text/index.js';
import { WarningFilled, WarningAltFilled, Checkmark } from '@carbon/icons-react';
import ListBox from '../ListBox/index.js';
import setupGetInstanceId from '../../tools/setupGetInstanceId.js';
import mergeRefs from '../../tools/mergeRefs.js';
import { useFeatureFlag } from '../FeatureFlags/index.js';
import deprecate from '../../prop-types/deprecate.js';
import { usePrefix } from '../../internal/usePrefix.js';
import '../FluidForm/FluidForm.js';
import { FormContext } from '../FluidForm/FormContext.js';
import { match } from '../../internal/keyboard/match.js';
import { Text } from '../Text/Text.js';
import ListBoxSelection from '../ListBox/next/ListBoxSelection.js';
import ListBoxTrigger from '../ListBox/next/ListBoxTrigger.js';
import { ListBoxSize, ListBoxType } from '../ListBox/ListBoxPropTypes.js';
import { Space, Enter } from '../../internal/keyboard/keys.js';

var _excluded = ["ariaLabel", "className", "direction", "disabled", "downshiftProps", "helperText", "id", "initialSelectedItem", "invalid", "invalidText", "items", "itemToElement", "itemToString", "light", "onChange", "onInputChange", "onToggleClick", "placeholder", "readOnly", "selectedItem", "shouldFilterItem", "size", "titleText", "translateWithId", "type", "warn", "warnText", "onStateChange"];

var defaultItemToString = function defaultItemToString(item) {
  if (typeof item === 'string') {
    return item;
  }

  return item && item.label;
};

var defaultShouldFilterItem = function defaultShouldFilterItem() {
  return true;
};

var getInputValue = function getInputValue(_ref) {
  var initialSelectedItem = _ref.initialSelectedItem,
      inputValue = _ref.inputValue,
      itemToString = _ref.itemToString,
      selectedItem = _ref.selectedItem;

  if (selectedItem) {
    return itemToString(selectedItem);
  }

  if (initialSelectedItem) {
    return itemToString(initialSelectedItem);
  }

  return inputValue || '';
};

var findHighlightedIndex = function findHighlightedIndex(_ref2, inputValue) {
  var items = _ref2.items,
      _ref2$itemToString = _ref2.itemToString,
      itemToString = _ref2$itemToString === void 0 ? defaultItemToString : _ref2$itemToString;

  if (!inputValue) {
    return -1;
  }

  var searchValue = inputValue.toLowerCase();

  for (var i = 0; i < items.length; i++) {
    var _item = itemToString(items[i]).toLowerCase();

    if (_item.indexOf(searchValue) !== -1) {
      return i;
    }
  }

  return -1;
};

var getInstanceId = setupGetInstanceId();
var ComboBox = /*#__PURE__*/React__default.forwardRef(function (props, ref) {
  var _cx, _ref4, _cx4, _Text;

  var ariaLabel = props.ariaLabel,
      containerClassName = props.className,
      direction = props.direction,
      disabled = props.disabled,
      downshiftProps = props.downshiftProps,
      helperText = props.helperText,
      id = props.id,
      initialSelectedItem = props.initialSelectedItem,
      invalid = props.invalid,
      invalidText = props.invalidText,
      items = props.items,
      itemToElement = props.itemToElement,
      itemToString = props.itemToString,
      light = props.light,
      onChange = props.onChange,
      onInputChange = props.onInputChange,
      onToggleClick = props.onToggleClick,
      placeholder = props.placeholder,
      readOnly = props.readOnly,
      selectedItem = props.selectedItem,
      shouldFilterItem = props.shouldFilterItem,
      size = props.size,
      titleText = props.titleText,
      translateWithId = props.translateWithId;
      props.type;
      var warn = props.warn,
      warnText = props.warnText;
      props.onStateChange;
      var rest = _objectWithoutProperties(props, _excluded);

  var prefix = usePrefix();

  var _useContext = useContext(FormContext),
      isFluid = _useContext.isFluid;

  var textInput = useRef(null);
  var comboBoxInstanceId = getInstanceId();

  var _useState = useState(getInputValue({
    initialSelectedItem: initialSelectedItem,
    inputValue: '',
    itemToString: itemToString,
    selectedItem: selectedItem
  })),
      _useState2 = _slicedToArray(_useState, 2),
      inputValue = _useState2[0],
      setInputValue = _useState2[1];

  var _useState3 = useState(false),
      _useState4 = _slicedToArray(_useState3, 2),
      isFocused = _useState4[0],
      setIsFocused = _useState4[1];

  var _useState5 = useState(),
      _useState6 = _slicedToArray(_useState5, 2),
      prevSelectedItem = _useState6[0],
      setPrevSelectedItem = _useState6[1];

  var _useState7 = useState(false),
      _useState8 = _slicedToArray(_useState7, 2),
      doneInitialSelectedItem = _useState8[0],
      setDoneInitialSelectedItem = _useState8[1];

  var savedOnInputChange = useRef(onInputChange);

  if (!doneInitialSelectedItem || prevSelectedItem !== selectedItem) {
    setDoneInitialSelectedItem(true);
    setPrevSelectedItem(selectedItem);
    setInputValue(getInputValue({
      initialSelectedItem: initialSelectedItem,
      inputValue: inputValue,
      itemToString: itemToString,
      selectedItem: selectedItem
    }));
  }

  var filterItems = function filterItems(items, itemToString, inputValue) {
    return items.filter(function (item) {
      return shouldFilterItem ? shouldFilterItem({
        item: item,
        itemToString: itemToString,
        inputValue: inputValue
      }) : defaultShouldFilterItem();
    });
  };

  var handleOnChange = function handleOnChange(selectedItem) {
    if (onChange) {
      onChange({
        selectedItem: selectedItem
      });
    }
  };

  var handleOnInputValueChange = function handleOnInputValueChange(inputValue) {
    setInputValue(inputValue || '');
  };

  useEffect(function () {
    savedOnInputChange.current = onInputChange;
  }, [onInputChange]);
  useEffect(function () {
    if (savedOnInputChange.current) {
      savedOnInputChange.current(inputValue);
    }
  }, [inputValue]);

  var handleSelectionClear = function handleSelectionClear() {
    if (textInput !== null && textInput !== void 0 && textInput.current) {
      textInput.current.focus();
    }
  };

  var handleOnStateChange = function handleOnStateChange(newState, _ref3) {
    var setHighlightedIndex = _ref3.setHighlightedIndex;

    if (Object.prototype.hasOwnProperty.call(newState, 'inputValue')) {
      var _inputValue = newState.inputValue;
      var filteredItems = filterItems(items, itemToString, _inputValue);
      setHighlightedIndex(findHighlightedIndex(_objectSpread2(_objectSpread2({}, props), {}, {
        items: filteredItems
      }), _inputValue));
    }
  };

  var handleToggleClick = function handleToggleClick(isOpen) {
    return function (event) {
      if (onToggleClick) {
        onToggleClick(event);
      }

      if (event.target === textInput.current && isOpen) {
        event.preventDownshiftDefault = true;
        event.persist();
      }
    };
  };

  var enabled = useFeatureFlag('enable-v11-release');
  var showWarning = !invalid && warn;
  var className = cx("".concat(prefix, "--combo-box"), [enabled ? null : containerClassName], (_cx = {}, _defineProperty(_cx, "".concat(prefix, "--list-box--up"), direction === 'top'), _defineProperty(_cx, "".concat(prefix, "--combo-box--warning"), showWarning), _defineProperty(_cx, "".concat(prefix, "--combo-box--readonly"), readOnly), _cx));
  var titleClasses = cx("".concat(prefix, "--label"), _defineProperty({}, "".concat(prefix, "--label--disabled"), disabled));
  var comboBoxHelperId = !helperText ? undefined : "combobox-helper-text-".concat(comboBoxInstanceId);
  var helperClasses = cx("".concat(prefix, "--form__helper-text"), _defineProperty({}, "".concat(prefix, "--form__helper-text--disabled"), disabled));
  var wrapperClasses = cx("".concat(prefix, "--list-box__wrapper"), [enabled ? containerClassName : null, (_ref4 = {}, _defineProperty(_ref4, "".concat(prefix, "--list-box__wrapper--fluid--invalid"), isFluid && invalid), _defineProperty(_ref4, "".concat(prefix, "--list-box__wrapper--fluid--focus"), isFluid && isFocused), _ref4)]);
  var inputClasses = cx("".concat(prefix, "--text-input"), (_cx4 = {}, _defineProperty(_cx4, "".concat(prefix, "--text-input--empty"), !inputValue), _defineProperty(_cx4, "".concat(prefix, "--combo-box--input--focus"), isFocused && !isFluid), _cx4)); // needs to be Capitalized for react to render it correctly

  var ItemToElement = itemToElement;
  return /*#__PURE__*/React__default.createElement(Downshift, _extends({}, downshiftProps, {
    onChange: handleOnChange,
    onInputValueChange: handleOnInputValueChange,
    onStateChange: function onStateChange() {
      var _downshiftProps$onSta;

      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      handleOnStateChange.apply(void 0, args);
      downshiftProps === null || downshiftProps === void 0 ? void 0 : (_downshiftProps$onSta = downshiftProps.onStateChange) === null || _downshiftProps$onSta === void 0 ? void 0 : _downshiftProps$onSta.call.apply(_downshiftProps$onSta, [downshiftProps].concat(args));
    },
    inputValue: inputValue || '',
    itemToString: itemToString,
    initialSelectedItem: initialSelectedItem,
    inputId: id,
    selectedItem: selectedItem
  }), function (_ref5) {
    var _textInput$current;

    var getInputProps = _ref5.getInputProps,
        getItemProps = _ref5.getItemProps,
        getLabelProps = _ref5.getLabelProps,
        getMenuProps = _ref5.getMenuProps,
        getRootProps = _ref5.getRootProps,
        getToggleButtonProps = _ref5.getToggleButtonProps,
        isOpen = _ref5.isOpen,
        inputValue = _ref5.inputValue,
        selectedItem = _ref5.selectedItem,
        highlightedIndex = _ref5.highlightedIndex,
        clearSelection = _ref5.clearSelection,
        toggleMenu = _ref5.toggleMenu;
    var rootProps = getRootProps( // @ts-ignore this is not supposed to be a required property
    {}, {
      suppressRefError: true
    });
    var labelProps = getLabelProps();
    var buttonProps = getToggleButtonProps({
      disabled: disabled || readOnly,
      onClick: handleToggleClick(isOpen),
      // When we moved the "root node" of Downshift to the <input> for
      // ARIA 1.2 compliance, we unfortunately hit this branch for the
      // "mouseup" event that downshift listens to:
      // https://github.com/downshift-js/downshift/blob/v5.2.1/src/downshift.js#L1051-L1065
      //
      // As a result, it will reset the state of the component and so we
      // stop the event from propagating to prevent this if the menu is already open.
      // This allows the toggleMenu behavior for the toggleButton to correctly open and
      // close the menu.
      onMouseUp: function onMouseUp(event) {
        if (isOpen) {
          event.stopPropagation();
        }
      }
    });
    var inputProps = getInputProps({
      // Remove excess aria `aria-labelledby`. HTML <label for> provides this aria information.
      'aria-labelledby': null,
      disabled: disabled,
      placeholder: placeholder,
      onClick: function onClick() {
        toggleMenu();
      },
      onKeyDown: function onKeyDown(event) {
        if (match(event, Space)) {
          event.stopPropagation();
        }

        if (match(event, Enter) && !inputValue) {
          toggleMenu();
        }
      }
    });

    var handleFocus = function handleFocus(evt) {
      setIsFocused(evt.type === 'focus');
    };

    var readOnlyEventHandlers = readOnly ? {
      onKeyDown: function onKeyDown(evt) {
        // This prevents the select from opening for the above keys
        if (evt.key !== 'Tab') {
          evt.preventDefault();
        }
      }
    } : {};
    return /*#__PURE__*/React__default.createElement("div", {
      className: wrapperClasses
    }, titleText && /*#__PURE__*/React__default.createElement(Text, _extends({
      as: "label",
      className: titleClasses
    }, labelProps), titleText), /*#__PURE__*/React__default.createElement(ListBox, {
      onFocus: handleFocus,
      onBlur: handleFocus,
      className: className,
      disabled: disabled,
      invalid: invalid,
      invalidText: invalidText,
      isOpen: isOpen,
      light: light,
      size: size,
      warn: warn,
      warnText: warnText
    }, /*#__PURE__*/React__default.createElement("div", {
      className: "".concat(prefix, "--list-box__field")
    }, /*#__PURE__*/React__default.createElement("input", _extends({
      role: "combobox",
      disabled: disabled,
      className: inputClasses,
      type: "text",
      tabIndex: "0",
      "aria-autocomplete": "list",
      "aria-expanded": rootProps['aria-expanded'],
      "aria-haspopup": "listbox",
      "aria-controls": inputProps['aria-controls'],
      title: textInput === null || textInput === void 0 ? void 0 : (_textInput$current = textInput.current) === null || _textInput$current === void 0 ? void 0 : _textInput$current.value
    }, inputProps, rest, readOnlyEventHandlers, {
      readOnly: readOnly,
      ref: mergeRefs(textInput, ref)
    })), invalid && /*#__PURE__*/React__default.createElement(WarningFilled, {
      className: "".concat(prefix, "--list-box__invalid-icon")
    }), showWarning && /*#__PURE__*/React__default.createElement(WarningAltFilled, {
      className: "".concat(prefix, "--list-box__invalid-icon ").concat(prefix, "--list-box__invalid-icon--warning")
    }), inputValue && /*#__PURE__*/React__default.createElement(ListBoxSelection, {
      clearSelection: clearSelection,
      translateWithId: translateWithId,
      disabled: disabled || readOnly,
      onClearSelection: handleSelectionClear,
      selectionCount: 0
    }), /*#__PURE__*/React__default.createElement(ListBoxTrigger, _extends({}, buttonProps, {
      isOpen: isOpen,
      translateWithId: translateWithId
    }))), /*#__PURE__*/React__default.createElement(ListBox.Menu, getMenuProps({
      'aria-label': ariaLabel
    }), isOpen ? filterItems(items, itemToString, inputValue).map(function (item, index) {
      var _getItemProps;

      var itemProps = getItemProps((_getItemProps = {
        item: item,
        index: index
      }, _defineProperty(_getItemProps, 'aria-current', selectedItem === item ? 'true' : 'false'), _defineProperty(_getItemProps, 'aria-selected', highlightedIndex === index ? 'true' : 'false'), _defineProperty(_getItemProps, "disabled", item.disabled), _getItemProps));
      return /*#__PURE__*/React__default.createElement(ListBox.MenuItem, _extends({
        key: itemProps.id,
        isActive: selectedItem === item,
        isHighlighted: highlightedIndex === index || (selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.id) && (selectedItem === null || selectedItem === void 0 ? void 0 : selectedItem.id) === item.id || false,
        title: itemToElement ? item.text : itemToString ? itemToString(item) : undefined
      }, itemProps), itemToElement ?
      /*#__PURE__*/
      // @ts-ignore
      React__default.createElement(ItemToElement, _extends({
        key: itemProps.id
      }, item)) : itemToString ? itemToString(item) : defaultItemToString(item), selectedItem === item && /*#__PURE__*/React__default.createElement(Checkmark, {
        className: "".concat(prefix, "--list-box__menu-item__selected-icon")
      }));
    }) : null)), helperText && !invalid && !warn && !isFluid && (_Text || (_Text = /*#__PURE__*/React__default.createElement(Text, {
      as: "div",
      id: comboBoxHelperId,
      className: helperClasses
    }, helperText))));
  });
});
ComboBox.displayName = 'ComboBox';
ComboBox.propTypes = {
  /**
   * 'aria-label' of the ListBox component.
   */
  ariaLabel: PropTypes.string,

  /**
   * An optional className to add to the container node
   */
  className: PropTypes.string,

  /**
   * Specify the direction of the combobox dropdown. Can be either top or bottom.
   */
  direction: PropTypes.oneOf(['top', 'bottom']),

  /**
   * Specify if the control should be disabled, or not
   */
  disabled: PropTypes.bool,

  /**
   * Additional props passed to Downshift
   */
  // @ts-ignore
  downshiftProps: PropTypes.shape(Downshift.propTypes),

  /**
   * Provide helper text that is used alongside the control label for
   * additional help
   */
  helperText: PropTypes.string,

  /**
   * Specify a custom `id` for the input
   */
  id: PropTypes.string.isRequired,

  /**
   * Allow users to pass in an arbitrary item or a string (in case their items are an array of strings)
   * from their collection that are pre-selected
   */
  initialSelectedItem: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.number]),

  /**
   * Specify if the currently selected value is invalid.
   */
  invalid: PropTypes.bool,

  /**
   * Message which is displayed if the value is invalid.
   */
  invalidText: PropTypes.node,

  /**
   * Optional function to render items as custom components instead of strings.
   * Defaults to null and is overridden by a getter
   */
  itemToElement: PropTypes.func,

  /**
   * Helper function passed to downshift that allows the library to render a
   * given item to a string label. By default, it extracts the `label` field
   * from a given item to serve as the item label in the list
   */
  itemToString: PropTypes.func,

  /**
   * We try to stay as generic as possible here to allow individuals to pass
   * in a collection of whatever kind of data structure they prefer
   */
  items: PropTypes.array.isRequired,

  /**
   * should use "light theme" (white background)?
   */
  light: deprecate(PropTypes.bool, 'The `light` prop for `Combobox` has ' + 'been deprecated in favor of the new `Layer` component. It will be removed in the next major release.'),

  /**
   * `onChange` is a utility for this controlled component to communicate to a
   * consuming component when a specific dropdown item is selected.
   * `({ selectedItem }) => void`
   * @param {{ selectedItem }}
   */
  onChange: PropTypes.func.isRequired,

  /**
   * Callback function to notify consumer when the text input changes.
   * This provides support to change available items based on the text.
   * `(inputText) => void`
   * @param {string} inputText
   */
  onInputChange: PropTypes.func,

  /**
   * Helper function passed to Downshift that allows the user to observe internal
   * state changes
   * `(changes, stateAndHelpers) => void`
   */
  onStateChange: PropTypes.func,

  /**
   * Callback function that fires when the combobox menu toggle is clicked
   * `(evt) => void`
   * @param {MouseEvent} event
   */
  onToggleClick: PropTypes.func,

  /**
   * Used to provide a placeholder text node before a user enters any input.
   * This is only present if the control has no items selected
   */
  placeholder: PropTypes.string,

  /**
   * Is the ComboBox readonly?
   */
  readOnly: PropTypes.bool,

  /**
   * For full control of the selection
   */
  selectedItem: PropTypes.oneOfType([PropTypes.object, PropTypes.string, PropTypes.number]),

  /**
   * Specify your own filtering logic by passing in a `shouldFilterItem`
   * function that takes in the current input and an item and passes back
   * whether or not the item should be filtered.
   */
  shouldFilterItem: PropTypes.func,

  /**
   * Specify the size of the ListBox. Currently supports either `sm`, `md` or `lg` as an option.
   */
  size: ListBoxSize,

  /**
   * Provide text to be used in a `<label>` element that is tied to the
   * combobox via ARIA attributes.
   */
  titleText: PropTypes.node,

  /**
   * Specify a custom translation function that takes in a message identifier
   * and returns the localized string for the message
   */
  translateWithId: PropTypes.func,

  /**
   * Currently supports either the default type, or an inline variant
   */
  type: ListBoxType,

  /**
   * Specify whether the control is currently in warning state
   */
  warn: PropTypes.bool,

  /**
   * Provide the text that is displayed when the control is in warning state
   */
  warnText: PropTypes.node
};
ComboBox.defaultProps = {
  disabled: false,
  itemToString: defaultItemToString,
  itemToElement: null,
  shouldFilterItem: defaultShouldFilterItem,
  type: 'default',
  ariaLabel: 'Choose an item',
  direction: 'bottom'
};
var ComboBox$1 = ComboBox;

export { ComboBox$1 as default };
