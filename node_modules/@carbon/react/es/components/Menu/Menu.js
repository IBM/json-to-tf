/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

import { objectWithoutProperties as _objectWithoutProperties, objectSpread2 as _objectSpread2, slicedToArray as _slicedToArray, defineProperty as _defineProperty, extends as _extends, typeof as _typeof } from '../../_virtual/_rollupPluginBabelHelpers.js';
import cx from 'classnames';
import PropTypes from 'prop-types';
import React__default, { useRef, useContext, useReducer, useMemo, useState, useEffect } from 'react';
import { createPortal } from 'react-dom';
import { useMergedRefs } from '../../internal/useMergedRefs.js';
import { usePrefix } from '../../internal/usePrefix.js';
import { MenuContext, menuReducer } from './MenuContext.js';
import { match } from '../../internal/keyboard/match.js';
import { Escape, ArrowLeft, ArrowUp, ArrowDown } from '../../internal/keyboard/keys.js';

var _excluded = ["children", "className", "label", "onClose", "open", "size", "target", "x", "y"];
var spacing = 8; // distance to keep to window edges, in px

var Menu = /*#__PURE__*/React__default.forwardRef(function Menu(_ref, forwardRef) {
  var _cx;

  var children = _ref.children,
      className = _ref.className,
      label = _ref.label,
      onClose = _ref.onClose,
      open = _ref.open,
      _ref$size = _ref.size,
      size = _ref$size === void 0 ? 'sm' : _ref$size,
      _ref$target = _ref.target,
      target = _ref$target === void 0 ? document.body : _ref$target,
      _ref$x = _ref.x,
      x = _ref$x === void 0 ? 0 : _ref$x,
      _ref$y = _ref.y,
      y = _ref$y === void 0 ? 0 : _ref$y,
      rest = _objectWithoutProperties(_ref, _excluded);

  var prefix = usePrefix();
  var focusReturn = useRef(null);
  var context = useContext(MenuContext);
  var isRoot = context.state.isRoot;
  var menuSize = isRoot ? size : context.state.size;

  var _useReducer = useReducer(menuReducer, _objectSpread2(_objectSpread2({}, context.state), {}, {
    isRoot: false,
    size: size,
    requestCloseRoot: isRoot ? handleClose : context.state.requestCloseRoot
  })),
      _useReducer2 = _slicedToArray(_useReducer, 2),
      childState = _useReducer2[0],
      childDispatch = _useReducer2[1];

  var childContext = useMemo(function () {
    return {
      state: childState,
      dispatch: childDispatch
    };
  }, [childState, childDispatch]);
  var menu = useRef();
  var ref = useMergedRefs([forwardRef, menu]);

  var _useState = useState([-1, -1]),
      _useState2 = _slicedToArray(_useState, 2),
      position = _useState2[0],
      setPosition = _useState2[1];

  var focusableItems = childContext.state.items.filter(function (item) {
    return !item.disabled;
  });

  function returnFocus() {
    if (focusReturn.current) {
      focusReturn.current.focus();
    }
  }

  function handleOpen() {
    if (menu.current) {
      focusReturn.current = document.activeElement;
      setPosition(calculatePosition());
      menu.current.focus();
    }
  }

  function handleClose(e) {
    if (/^key/.test(e.type)) {
      window.addEventListener('keyup', returnFocus, {
        once: true
      });
    } else if (e.type === 'click' && menu.current) {
      menu.current.addEventListener('focusout', returnFocus, {
        once: true
      });
    } else {
      returnFocus();
    }

    if (onClose) {
      onClose();
    }
  }

  function handleKeyDown(e) {
    e.stopPropagation();
    var currentItem = focusableItems.findIndex(function (item) {
      return item.ref.current.contains(document.activeElement);
    });
    var indexToFocus = currentItem; // if the user presses escape or this is a submenu
    // and the user presses ArrowLeft, close it

    if ((match(e, Escape) || !isRoot && match(e, ArrowLeft)) && onClose) {
      handleClose(e);
    } else {
      // if currentItem is -1, the menu itself is focused.
      // in this case, the arrow keys define the first item
      // to be focused.
      if (match(e, ArrowUp)) {
        indexToFocus = currentItem === -1 ? focusableItems.length - 1 : indexToFocus - 1;
      }

      if (match(e, ArrowDown)) {
        indexToFocus = currentItem === -1 ? 0 : indexToFocus + 1;
      }

      if (indexToFocus < 0) {
        indexToFocus = 0;
      }

      if (indexToFocus >= focusableItems.length) {
        indexToFocus = focusableItems.length - 1;
      }

      if (indexToFocus !== currentItem) {
        var nodeToFocus = focusableItems[indexToFocus];
        nodeToFocus.ref.current.focus();
      }
    }
  }

  function handleBlur(e) {
    if (open && onClose && isRoot && !menu.current.contains(e.relatedTarget)) {
      handleClose(e);
    }
  }

  function fitValue(range, axis) {
    var _menu$current$getBoun = menu.current.getBoundingClientRect(),
        width = _menu$current$getBoun.width,
        height = _menu$current$getBoun.height;

    var alignment = isRoot ? 'vertical' : 'horizontal';
    var axes = {
      x: {
        max: window.innerWidth,
        size: width,
        anchor: alignment === 'horizontal' ? range[1] : range[0],
        reversedAnchor: alignment === 'horizontal' ? range[0] : range[1],
        offset: 0
      },
      y: {
        max: window.innerHeight,
        size: height,
        anchor: alignment === 'horizontal' ? range[0] : range[1],
        reversedAnchor: alignment === 'horizontal' ? range[1] : range[0],
        offset: isRoot ? 0 : 4 // top padding in menu, used to align the menu items

      }
    };
    var _axes$axis = axes[axis],
        max = _axes$axis.max,
        size = _axes$axis.size,
        anchor = _axes$axis.anchor,
        reversedAnchor = _axes$axis.reversedAnchor,
        offset = _axes$axis.offset; // get values for different scenarios, set to false if they don't work

    var options = [// towards max (preferred)
    max - spacing - size - anchor >= 0 ? anchor - offset : false, // towards min / reversed (first fallback)
    reversedAnchor - size >= 0 ? reversedAnchor - size + offset : false, // align at max (second fallback)
    max - spacing - size];
    var bestOption = options.find(function (option) {
      return option !== false;
    });
    return bestOption >= spacing ? bestOption : spacing;
  }

  function calculatePosition() {
    if (menu.current) {
      var ranges = {
        x: _typeof(x) === 'object' && x.length === 2 ? x : [x, x],
        y: _typeof(y) === 'object' && y.length === 2 ? y : [y, y]
      };
      return [fitValue(ranges.x, 'x'), fitValue(ranges.y, 'y')];
    }

    return [-1, -1];
  }

  useEffect(function () {
    if (open) {
      handleOpen();
    } else {
      // reset position when menu is closed in order for the --shown
      // modifier to be applied correctly
      setPosition(-1, -1);
    } // eslint-disable-next-line react-hooks/exhaustive-deps

  }, [open]);
  var classNames = cx(className, "".concat(prefix, "--menu"), "".concat(prefix, "--menu--").concat(menuSize), (_cx = {}, _defineProperty(_cx, "".concat(prefix, "--menu--open"), open), _defineProperty(_cx, "".concat(prefix, "--menu--shown"), position[0] >= 0 && position[1] >= 0), _defineProperty(_cx, "".concat(prefix, "--menu--with-icons"), childContext.state.hasIcons), _cx));
  var rendered = /*#__PURE__*/React__default.createElement(MenuContext.Provider, {
    value: childContext
  }, /*#__PURE__*/React__default.createElement("ul", _extends({}, rest, {
    className: classNames,
    role: "menu",
    ref: ref,
    "aria-label": label,
    tabIndex: -1,
    onKeyDown: handleKeyDown,
    onBlur: handleBlur // eslint-disable-next-line react/forbid-dom-props
    ,
    style: {
      left: "".concat(position[0], "px"),
      top: "".concat(position[1], "px")
    }
  }), children));
  return isRoot ? open && /*#__PURE__*/createPortal(rendered, target) || null : rendered;
});
Menu.propTypes = {
  /**
   * A collection of MenuItems to be rendered within this Menu.
   */
  children: PropTypes.node,

  /**
   * Additional CSS class names.
   */
  className: PropTypes.string,

  /**
   * A label describing the Menu.
   */
  label: PropTypes.string,

  /**
   * Provide an optional function to be called when the Menu should be closed.
   */
  onClose: PropTypes.func,

  /**
   * Whether the Menu is open or not.
   */
  open: PropTypes.bool,

  /**
   * Specify the size of the Menu.
   */
  size: PropTypes.oneOf(['xs', 'sm', 'md', 'lg']),

  /**
   * Specify a DOM node where the Menu should be rendered in. Defaults to document.body.
   */
  target: PropTypes.object,

  /**
   * Specify the x position of the Menu. Either pass a single number or an array with two numbers describing your activator's boundaries ([x1, x2])
   */
  x: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)]),

  /**
   * Specify the y position of the Menu. Either pass a single number or an array with two numbers describing your activator's boundaries ([y1, y2])
   */
  y: PropTypes.oneOfType([PropTypes.number, PropTypes.arrayOf(PropTypes.number)])
};

export { Menu };
