/**
 * Copyright IBM Corp. 2016, 2023
 *
 * This source code is licensed under the Apache-2.0 license found in the
 * LICENSE file in the root directory of this source tree.
 */

'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _rollupPluginBabelHelpers = require('../../_virtual/_rollupPluginBabelHelpers.js');
var cx = require('classnames');
var PropTypes = require('prop-types');
var React = require('react');
var icons = require('@carbon/react/icons');
var useControllableState = require('../../internal/useControllableState.js');
var useMergedRefs = require('../../internal/useMergedRefs.js');
var usePrefix = require('../../internal/usePrefix.js');
var Menu = require('./Menu.js');
var MenuContext = require('./MenuContext.js');
var match = require('../../internal/keyboard/match.js');
var keys = require('../../internal/keyboard/keys.js');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var cx__default = /*#__PURE__*/_interopDefaultLegacy(cx);
var PropTypes__default = /*#__PURE__*/_interopDefaultLegacy(PropTypes);
var React__default = /*#__PURE__*/_interopDefaultLegacy(React);

var _CaretRight;

var _excluded = ["children", "className", "disabled", "kind", "label", "onClick", "renderIcon", "shortcut"],
    _excluded2 = ["className", "defaultSelected", "label", "onChange", "selected"],
    _excluded3 = ["children", "className", "label"],
    _excluded4 = ["className", "defaultSelectedItem", "items", "itemToString", "label", "onChange", "selectedItem"],
    _excluded5 = ["className"];
var hoverIntentDelay = 150; // in ms

var MenuItem = /*#__PURE__*/React__default["default"].forwardRef(function MenuItem(_ref, forwardRef) {
  var _cx;

  var children = _ref.children,
      className = _ref.className,
      disabled = _ref.disabled,
      _ref$kind = _ref.kind,
      kind = _ref$kind === void 0 ? 'default' : _ref$kind,
      label = _ref.label,
      onClick = _ref.onClick,
      IconElement = _ref.renderIcon,
      shortcut = _ref.shortcut,
      rest = _rollupPluginBabelHelpers.objectWithoutProperties(_ref, _excluded);

  var prefix = usePrefix.usePrefix();
  var context = React.useContext(MenuContext.MenuContext);
  var menuItem = React.useRef();
  var ref = useMergedRefs.useMergedRefs([forwardRef, menuItem]);

  var _useState = React.useState({
    x: -1,
    y: -1
  }),
      _useState2 = _rollupPluginBabelHelpers.slicedToArray(_useState, 2),
      boundaries = _useState2[0],
      setBoundaries = _useState2[1];

  var hasChildren = Boolean(children);

  var _useState3 = React.useState(false),
      _useState4 = _rollupPluginBabelHelpers.slicedToArray(_useState3, 2),
      submenuOpen = _useState4[0],
      setSubmenuOpen = _useState4[1];

  var hoverIntentTimeout = React.useRef(null);
  var isDisabled = disabled && !hasChildren;
  var isDanger = kind === 'danger' && !hasChildren;

  function registerItem() {
    context.dispatch({
      type: 'registerItem',
      payload: {
        ref: menuItem,
        disabled: Boolean(disabled)
      }
    });
  }

  function openSubmenu() {
    var _menuItem$current$get = menuItem.current.getBoundingClientRect(),
        x = _menuItem$current$get.x,
        y = _menuItem$current$get.y,
        width = _menuItem$current$get.width,
        height = _menuItem$current$get.height;

    setBoundaries({
      x: [x, x + width],
      y: [y, y + height]
    });
    setSubmenuOpen(true);
  }

  function closeSubmenu() {
    setSubmenuOpen(false);
    setBoundaries({
      x: -1,
      y: -1
    });
  }

  function handleClick(e) {
    if (!isDisabled) {
      if (hasChildren) {
        openSubmenu();
      } else {
        context.state.requestCloseRoot(e);

        if (onClick) {
          onClick(e);
        }
      }
    }
  }

  function handleMouseEnter() {
    hoverIntentTimeout.current = setTimeout(function () {
      openSubmenu();
    }, hoverIntentDelay);
  }

  function handleMouseLeave() {
    clearTimeout(hoverIntentTimeout.current);
    closeSubmenu();
    menuItem.current.focus();
  }

  function handleKeyDown(e) {
    if (hasChildren && match.match(e, keys.ArrowRight)) {
      openSubmenu();
    }

    if (match.match(e, keys.Enter) || match.match(e, keys.Space)) {
      handleClick(e);
    }

    if (rest.onKeyDown) {
      rest.onKeyDown(e);
    }
  }

  var classNames = cx__default["default"](className, "".concat(prefix, "--menu-item"), (_cx = {}, _rollupPluginBabelHelpers.defineProperty(_cx, "".concat(prefix, "--menu-item--disabled"), isDisabled), _rollupPluginBabelHelpers.defineProperty(_cx, "".concat(prefix, "--menu-item--danger"), isDanger), _cx)); // on first render, register this menuitem in the context's state
  // (used for keyboard navigation)

  React.useEffect(function () {
    registerItem(); // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);
  return /*#__PURE__*/React__default["default"].createElement("li", _rollupPluginBabelHelpers["extends"]({
    role: "menuitem"
  }, rest, {
    ref: ref,
    className: classNames,
    tabIndex: "-1",
    "aria-disabled": isDisabled || null,
    "aria-haspopup": hasChildren || null,
    "aria-expanded": hasChildren ? submenuOpen : null,
    onClick: handleClick,
    onMouseEnter: hasChildren ? handleMouseEnter : null,
    onMouseLeave: hasChildren ? handleMouseLeave : null,
    onKeyDown: handleKeyDown
  }), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "".concat(prefix, "--menu-item__icon")
  }, IconElement && /*#__PURE__*/React__default["default"].createElement(IconElement, null)), /*#__PURE__*/React__default["default"].createElement("div", {
    className: "".concat(prefix, "--menu-item__label")
  }, label), shortcut && !hasChildren && /*#__PURE__*/React__default["default"].createElement("div", {
    className: "".concat(prefix, "--menu-item__shortcut")
  }, shortcut), hasChildren && /*#__PURE__*/React__default["default"].createElement(React__default["default"].Fragment, null, /*#__PURE__*/React__default["default"].createElement("div", {
    className: "".concat(prefix, "--menu-item__shortcut")
  }, _CaretRight || (_CaretRight = /*#__PURE__*/React__default["default"].createElement(icons.CaretRight, null))), /*#__PURE__*/React__default["default"].createElement(Menu.Menu, {
    label: label,
    open: submenuOpen,
    onClose: function onClose() {
      closeSubmenu();
      menuItem.current.focus();
    },
    x: boundaries.x,
    y: boundaries.y
  }, children)));
});
MenuItem.propTypes = {
  /**
   * Optionally provide another Menu to create a submenu. props.children can't be used to specify the content of the MenuItem itself. Use props.label instead.
   */
  children: PropTypes__default["default"].node,

  /**
   * Additional CSS class names.
   */
  className: PropTypes__default["default"].string,

  /**
   * Specify whether the MenuItem is disabled or not.
   */
  disabled: PropTypes__default["default"].bool,

  /**
   * Specify the kind of the MenuItem.
   */
  kind: PropTypes__default["default"].oneOf(['default', 'danger']),

  /**
   * A required label titling the MenuItem. Will be rendered as its text content.
   */
  label: PropTypes__default["default"].string.isRequired,

  /**
   * Provide an optional function to be called when the MenuItem is clicked.
   */
  onClick: PropTypes__default["default"].func,

  /**
   * This prop is not intended for use. The only supported icons are Checkmarks to depict single- and multi-selects. This prop is used by MenuItemSelectable and MenuItemRadioGroup automatically.
   */
  renderIcon: PropTypes__default["default"].oneOfType([PropTypes__default["default"].func, PropTypes__default["default"].object]),

  /**
   * Provide a shortcut for the action of this MenuItem. Note that the component will only render it as a hint but not actually register the shortcut.
   */
  shortcut: PropTypes__default["default"].string
};
var MenuItemSelectable = /*#__PURE__*/React__default["default"].forwardRef(function MenuItemSelectable(_ref2, forwardRef) {
  var className = _ref2.className,
      defaultSelected = _ref2.defaultSelected,
      label = _ref2.label,
      onChange = _ref2.onChange,
      selected = _ref2.selected,
      rest = _rollupPluginBabelHelpers.objectWithoutProperties(_ref2, _excluded2);

  var prefix = usePrefix.usePrefix();
  var context = React.useContext(MenuContext.MenuContext);

  var _useControllableState = useControllableState.useControllableState({
    value: selected,
    onChange: onChange,
    defaultValue: defaultSelected !== null && defaultSelected !== void 0 ? defaultSelected : false
  }),
      _useControllableState2 = _rollupPluginBabelHelpers.slicedToArray(_useControllableState, 2),
      checked = _useControllableState2[0],
      setChecked = _useControllableState2[1];

  function handleClick(e) {
    setChecked(!checked);

    if (onChange) {
      onChange(e);
    }
  }

  React.useEffect(function () {
    if (!context.state.hasIcons) {
      context.dispatch({
        type: 'enableIcons'
      });
    }
  }, [context.state.hasIcons, context]);
  var classNames = cx__default["default"](className, "".concat(prefix, "--menu-item-selectable--selected"));
  return /*#__PURE__*/React__default["default"].createElement(MenuItem, _rollupPluginBabelHelpers["extends"]({}, rest, {
    ref: forwardRef,
    label: label,
    className: classNames,
    role: "menuitemcheckbox",
    "aria-checked": checked,
    renderIcon: checked && icons.Checkmark,
    onClick: handleClick
  }));
});
MenuItemSelectable.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: PropTypes__default["default"].string,

  /**
   * Specify whether the option should be selected by default.
   */
  defaultSelected: PropTypes__default["default"].bool,

  /**
   * A required label titling this option.
   */
  label: PropTypes__default["default"].string.isRequired,

  /**
   * Provide an optional function to be called when the selection state changes.
   */
  onChange: PropTypes__default["default"].func,

  /**
   * Pass a bool to props.selected to control the state of this option.
   */
  selected: PropTypes__default["default"].bool
};
var MenuItemGroup = /*#__PURE__*/React__default["default"].forwardRef(function MenuItemGroup(_ref3, forwardRef) {
  var children = _ref3.children,
      className = _ref3.className,
      label = _ref3.label,
      rest = _rollupPluginBabelHelpers.objectWithoutProperties(_ref3, _excluded3);

  var prefix = usePrefix.usePrefix();
  var classNames = cx__default["default"](className, "".concat(prefix, "--menu-item-group"));
  return /*#__PURE__*/React__default["default"].createElement("li", {
    className: classNames,
    role: "none",
    ref: forwardRef
  }, /*#__PURE__*/React__default["default"].createElement("ul", _rollupPluginBabelHelpers["extends"]({}, rest, {
    role: "group",
    "aria-label": label
  }), children));
});
MenuItemGroup.propTypes = {
  /**
   * A collection of MenuItems to be rendered within this group.
   */
  children: PropTypes__default["default"].node,

  /**
   * Additional CSS class names.
   */
  className: PropTypes__default["default"].string,

  /**
   * A required label titling this group.
   */
  label: PropTypes__default["default"].string.isRequired
};
var MenuItemRadioGroup = /*#__PURE__*/React__default["default"].forwardRef(function MenuItemRadioGroup(_ref4, forwardRef) {
  var className = _ref4.className,
      defaultSelectedItem = _ref4.defaultSelectedItem,
      items = _ref4.items,
      _ref4$itemToString = _ref4.itemToString,
      itemToString = _ref4$itemToString === void 0 ? function (item) {
    return item.toString();
  } : _ref4$itemToString,
      label = _ref4.label,
      onChange = _ref4.onChange,
      selectedItem = _ref4.selectedItem,
      rest = _rollupPluginBabelHelpers.objectWithoutProperties(_ref4, _excluded4);

  var prefix = usePrefix.usePrefix();
  var context = React.useContext(MenuContext.MenuContext);

  var _useControllableState3 = useControllableState.useControllableState({
    value: selectedItem,
    onChange: onChange,
    defaultValue: defaultSelectedItem
  }),
      _useControllableState4 = _rollupPluginBabelHelpers.slicedToArray(_useControllableState3, 2),
      selection = _useControllableState4[0],
      setSelection = _useControllableState4[1];

  function handleClick(item, e) {
    setSelection(item);

    if (onChange) {
      onChange(e);
    }
  }

  React.useEffect(function () {
    if (!context.state.hasIcons) {
      context.dispatch({
        type: 'enableIcons'
      });
    }
  }, [context.state.hasIcons, context]);
  var classNames = cx__default["default"](className, "".concat(prefix, "--menu-item-radio-group"));
  return /*#__PURE__*/React__default["default"].createElement("li", {
    className: classNames,
    role: "none",
    ref: forwardRef
  }, /*#__PURE__*/React__default["default"].createElement("ul", _rollupPluginBabelHelpers["extends"]({}, rest, {
    role: "group",
    "aria-label": label
  }), items.map(function (item, i) {
    return /*#__PURE__*/React__default["default"].createElement(MenuItem, {
      key: i,
      label: itemToString(item),
      role: "menuitemradio",
      "aria-checked": item === selection,
      renderIcon: item === selection && icons.Checkmark,
      onClick: function onClick(e) {
        handleClick(item, e);
      }
    });
  })));
});
MenuItemRadioGroup.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: PropTypes__default["default"].string,

  /**
   * Specify the default selected item. Must match the type of props.items.
   */
  defaultSelectedItem: PropTypes__default["default"].any,

  /**
   * Provide a function to convert an item to the string that will be rendered. Defaults to item.toString().
   */
  itemToString: PropTypes__default["default"].func,

  /**
   * Provide the options for this radio group. Can be of any type, as long as you provide an appropriate props.itemToString function.
   */
  items: PropTypes__default["default"].array,

  /**
   * A required label titling this radio group.
   */
  label: PropTypes__default["default"].string.isRequired,

  /**
   * Provide an optional function to be called when the selection changes.
   */
  onChange: PropTypes__default["default"].func,

  /**
   * Provide props.selectedItem to control the state of this radio group. Must match the type of props.items.
   */
  selectedItem: PropTypes__default["default"].any
};
var MenuItemDivider = /*#__PURE__*/React__default["default"].forwardRef(function MenuItemDivider(_ref5, forwardRef) {
  var className = _ref5.className,
      rest = _rollupPluginBabelHelpers.objectWithoutProperties(_ref5, _excluded5);

  var prefix = usePrefix.usePrefix();
  var classNames = cx__default["default"](className, "".concat(prefix, "--menu-item-divider"));
  return /*#__PURE__*/React__default["default"].createElement("li", _rollupPluginBabelHelpers["extends"]({}, rest, {
    className: classNames,
    role: "separator",
    ref: forwardRef
  }));
});
MenuItemDivider.propTypes = {
  /**
   * Additional CSS class names.
   */
  className: PropTypes__default["default"].string
};

exports.MenuItem = MenuItem;
exports.MenuItemDivider = MenuItemDivider;
exports.MenuItemGroup = MenuItemGroup;
exports.MenuItemRadioGroup = MenuItemRadioGroup;
exports.MenuItemSelectable = MenuItemSelectable;
